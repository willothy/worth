use super::intrinsics::gen_intrinsics;
use super::ops;
use crate::{asm, comment, global, label, segment, sys_exit, OutputType};
use crate::{instruction::*, CompilerOptions};

use super::intrinsics;

pub fn compile(program: &Program, opt: CompilerOptions) -> Result<(), Box<dyn std::error::Error>> {
    let mut asm = vec![];
    comment!(asm, "-- generated by the worth compiler --");
    //asm.push("BITS 64".to_owned());
    segment!(asm, "text");
    global!(asm, "_start");
    label!(asm, "_start");

    let Program {
        instructions: program,
        name: program_name,
    } = program;

    for inst in program {
        match &inst {
            Instruction::Push(val) => match val {
                Value::Int(i) => {
                    asm!(asm, &format!("push    {}", i))
                }
                Value::Char(_) => todo!(),
                Value::Ptr(_) => todo!(),
            },
            Instruction::Intrinsic(intrinsic) => compile_intrinsic(&mut asm, intrinsic),
            Instruction::If { else_ip } => {
                comment!(asm, "-- if --");
                asm!(
                    asm,
                    "pop     rax",
                    "test    rax, rax",
                    &format!("jz      addr_{}", else_ip)
                );
            }
            Instruction::Else { else_ip, end_ip } => {
                comment!(asm, "-- else --");
                asm!(asm, &format!("jmp     addr_{}", end_ip));
                label!(asm, &format!("addr_{}", else_ip));
            }
            Instruction::End { end_ip } => {
                label!(asm, &format!("addr_{}", end_ip));
            }
            Instruction::Add => ops::add(&mut asm),
            Instruction::Sub => ops::sub(&mut asm),
            Instruction::Mul => ops::mul(&mut asm),
            Instruction::Div => ops::div(&mut asm),
            Instruction::Mod => ops::rem(&mut asm),
            Instruction::And => ops::and(&mut asm),
            Instruction::Or => ops::or(&mut asm),
            Instruction::Xor => ops::xor(&mut asm),
            Instruction::Not => ops::not(&mut asm),
            Instruction::Shl => ops::shl(&mut asm),
            Instruction::Shr => ops::shr(&mut asm),
            Instruction::Eq => ops::eq(&mut asm),
            Instruction::Neq => ops::neq(&mut asm),
            Instruction::Lt => ops::lt(&mut asm),
            Instruction::Gt => ops::gt(&mut asm),
            Instruction::Lte => ops::lte(&mut asm),
            Instruction::Gte => ops::gte(&mut asm),
        }
    }

    asm!(asm, "pop     rbx");
    sys_exit!(asm, "rbx");

    gen_intrinsics(&mut asm);

    // Write asm to out.asm
    let out_path = opt.output.unwrap_or_else(|| program_name.into());
    let output_type = match out_path.extension() {
        Some(ext) => match ext.to_str().unwrap() {
            "asm" => OutputType::Asm,
            "o" => OutputType::Obj,
            "exe" => OutputType::Exe,
            _ => {
                eprintln!(
                    "Warning: Unknown output type {}. Building elf64 executable.",
                    ext.to_str().unwrap()
                );
                OutputType::Exe
            }
        },
        None => OutputType::Exe,
    };
    let asm_out_path = out_path.with_extension("asm");
    let asm_out_path_str = asm_out_path
        .with_extension("asm")
        .to_string_lossy()
        .to_string();
    let obj_out_path_str = asm_out_path
        .with_extension("o")
        .to_string_lossy()
        .to_string();
    let exe_out_path_str = asm_out_path
        .with_extension("")
        .to_string_lossy()
        .to_string();

    std::fs::write(asm_out_path, asm.join("\n"))?;

    if matches!(output_type, OutputType::Asm) {
        return Ok(());
    }

    // Call nasm

    let _nasm = std::process::Command::new("nasm")
        .args(&[&asm_out_path_str, "-f", "elf64", "-o", &obj_out_path_str])
        .spawn()?
        .wait()?;
    std::fs::remove_file(asm_out_path_str)?;

    if matches!(output_type, OutputType::Obj) {
        return Ok(());
    }

    // Call ld
    let _ld = std::process::Command::new("ld")
        .args(&[&obj_out_path_str, "-o", &exe_out_path_str])
        .spawn()?
        .wait()?;
    std::fs::remove_file(obj_out_path_str)?;

    Ok(())
}

fn compile_intrinsic(asm: &mut Vec<String>, intrinsic: &Intrinsic) {
    comment!(
        asm,
        &format!("-- intrinsic: {} --", intrinsic.to_string().to_lowercase())
    );
    match intrinsic {
        Intrinsic::Panic => intrinsics::panic(asm),
        Intrinsic::Dump => intrinsics::dump(asm),
    }
    comment!(asm, "-- end intrinsic --");
}
